# Smash - Technical Specifications

**Version:** 1.0  
**Last Updated:** November 2024  
**Platform:** iOS & Android (React Native)

---

## Table of Contents

1. [Tech Stack](#tech-stack)
2. [Project Structure](#project-structure)
3. [Database Schema](#database-schema)
4. [Authentication](#authentication)
5. [App Architecture](#app-architecture)
6. [Key Features Implementation](#key-features-implementation)
7. [Real-time & Notifications](#real-time--notifications)
8. [Deep Linking](#deep-linking)
9. [Development Setup](#development-setup)
10. [Deployment](#deployment)

---

## Tech Stack

### Frontend
```
Framework: React Native 0.74+
Platform: Expo SDK 51+
Language: JavaScript (TypeScript optional)
Navigation: React Navigation v6
State Management: React Context + Hooks
UI Library: React Native core components
Styling: StyleSheet (React Native)
```

### Backend
```
Database: Firebase Firestore
Authentication: Firebase Authentication
Storage: Firebase Storage
Push Notifications: Firebase Cloud Messaging (FCM)
Functions: Firebase Cloud Functions (optional)
Hosting: Firebase Hosting (for web landing pages)
```

### Key Dependencies
```json
{
  "expo": "~51.0.0",
  "react": "18.2.0",
  "react-native": "0.74.0",
  "@react-navigation/native": "^6.1.0",
  "@react-navigation/bottom-tabs": "^6.5.0",
  "@react-navigation/stack": "^6.3.0",
  "firebase": "^10.7.0",
  "expo-notifications": "~0.28.0",
  "expo-image-picker": "~15.0.0",
  "react-native-safe-area-context": "4.10.0",
  "expo-linking": "~6.3.0"
}
```

### Development Tools
```
IDE: GitHub Codespaces (cloud) or VS Code (local)
Version Control: Git + GitHub
Testing Device: Expo Go app (iOS/Android)
Debugging: React Native Debugger, Expo Dev Tools
```

---

## Project Structure

### Folder Organization
```
/smash-app
├── /assets
│   ├── /fonts              # General Sans font files
│   ├── /images             # App images, icons
│   └── /animations         # Lottie files (if any)
├── /src
│   ├── /components         # Reusable components
│   │   ├── /ui             # Basic UI components
│   │   │   ├── Button.jsx
│   │   │   ├── Input.jsx
│   │   │   ├── Card.jsx
│   │   │   └── Avatar.jsx
│   │   ├── /tournament     # Tournament components
│   │   ├── /match          # Match components
│   │   └── /profile        # Profile components
│   ├── /screens            # App screens
│   │   ├── /auth           # Auth screens
│   │   │   ├── WelcomeScreen.jsx
│   │   │   ├── SignupScreen.jsx
│   │   │   └── LoginScreen.jsx
│   │   ├── /home           # Home tab
│   │   │   └── HomeScreen.jsx
│   │   ├── /compete        # Compete tab
│   │   │   ├── CompeteScreen.jsx
│   │   │   └── TournamentDetailScreen.jsx
│   │   ├── /updates        # Updates tab
│   │   │   └── UpdatesScreen.jsx
│   │   └── /profile        # Profile tab
│   │       └── ProfileScreen.jsx
│   ├── /navigation         # Navigation setup
│   │   ├── AppNavigator.jsx
│   │   ├── TabNavigator.jsx
│   │   └── AuthNavigator.jsx
│   ├── /contexts           # React Context
│   │   ├── AuthContext.jsx
│   │   ├── UserContext.jsx
│   │   └── TournamentContext.jsx
│   ├── /services           # Firebase services
│   │   ├── auth.js
│   │   ├── firestore.js
│   │   ├── storage.js
│   │   └── notifications.js
│   ├── /utils              # Helper functions
│   │   ├── validators.js
│   │   ├── dateUtils.js
│   │   └── tournamentLogic.js
│   ├── /constants          # Constants
│   │   ├── Colors.js
│   │   ├── Fonts.js
│   │   ├── Spacing.js
│   │   └── Config.js
│   └── /hooks              # Custom hooks
│       ├── useAuth.js
│       ├── useTournaments.js
│       └── useNotifications.js
├── /docs                   # Documentation
│   ├── PRD.md
│   ├── DESIGN.md
│   ├── TECH_SPEC.md
│   └── PROJECT_CONTEXT.md
├── App.jsx                 # Root component
├── app.json                # Expo config
├── firebase.json           # Firebase config
├── package.json
└── README.md
```

---

## Database Schema

### Firestore Collections

#### **users**
```javascript
{
  userId: string,              // Auto-generated by Firebase Auth
  email: string,               // User email (unique)
  displayName: string,         // User's chosen name
  profilePhoto: string | null, // URL from Firebase Storage or null
  createdAt: timestamp,        // Account creation date
  lastLogin: timestamp,        // Last login time
  stats: {
    tournamentsPlayed: number, // Total tournaments joined
    trophies: number,          // Tournaments won (1st place)
    matchesPlayed: number,     // Total matches
    matchesWon: number         // Total wins
  }
}

// Indexes: email, createdAt
```

#### **tournaments**
```javascript
{
  tournamentId: string,        // Auto-generated
  name: string,                // Tournament name
  photo: string | null,        // URL from Firebase Storage
  location: string,            // Venue location
  dateTime: timestamp,         // Tournament date & time
  courtNumbers: string[],      // Array: ["1", "2", "3"] or ["Court A", "Court B"]
  format: string,              // "worldCup" (only option for MVP)
  numberOfTeams: number,       // 4, 8, 12, 16, 20, 24
  rules: string,               // Custom rules text
  status: string,              // "registration", "groupStage", "knockout", "completed"
  adminId: string,             // Creator's userId
  createdAt: timestamp,
  updatedAt: timestamp,
  teams: [                     // Array of team objects
    {
      teamId: string,
      name: string,            // Auto-generated: "Team 1", "Team 2"
      players: [               // Array of 2 player IDs
        userId1,
        userId2
      ],
      groupId: string | null,  // Assigned after tournament starts
      stats: {
        played: number,
        won: number,
        lost: number,
        points: number         // Tournament points
      }
    }
  ],
  groups: [                    // Created when tournament starts
    {
      groupId: string,
      name: string,            // "Group A", "Group B"
      teamIds: string[]        // Array of team IDs in this group
    }
  ] | null
}

// Indexes: adminId, status, dateTime, createdAt
```

#### **matches**
```javascript
{
  matchId: string,             // Auto-generated
  tournamentId: string,        // Reference to tournament
  round: string,               // "groupStage", "quarterfinal", "semifinal", "final"
  groupId: string | null,      // For group stage matches
  team1Id: string,             // First team
  team2Id: string,             // Second team
  dateTime: timestamp,         // Scheduled match time
  court: string,               // Court number/name
  status: string,              // "scheduled", "inProgress", "completed"
  result: {
    team1Score: [number, number, number],  // Sets won: [6, 3, 6]
    team2Score: [number, number, number],  // Sets won: [4, 6, 2]
    winnerId: string,          // Winning team ID
    recordedBy: string,        // userId who recorded result
    recordedAt: timestamp
  } | null,
  createdAt: timestamp
}

// Indexes: tournamentId, status, dateTime, team1Id, team2Id
```

#### **notifications**
```javascript
{
  notificationId: string,      // Auto-generated
  userId: string,              // Recipient
  type: string,                // "invitation", "matchReminder", "resultPosted", "tournamentCancelled"
  title: string,               // Notification title
  body: string,                // Notification body
  data: {                      // Context data
    tournamentId: string | null,
    matchId: string | null
  },
  read: boolean,               // Read status
  createdAt: timestamp
}

// Indexes: userId, read, createdAt
```

---

## Authentication

### Authentication Flow

**Sign Up (Email):**
```javascript
1. User enters email
2. System checks if email exists
   - Exists → Redirect to login
   - New → Continue signup
3. Send 6-digit verification code to email
4. User enters code
5. User creates password (min 8 chars, 1 number, 1 letter)
6. User enters display name
7. Optional: Upload profile photo
8. Create Firebase Auth user
9. Create Firestore user document
10. Navigate to home (or tournament if from link)
```

**Login:**
```javascript
1. User enters email
2. User enters password
3. Firebase Auth signin
4. Fetch user data from Firestore
5. Store in AuthContext
6. Navigate to home (or tournament if from link)
```

**Forgot Password:**
```javascript
1. User enters email
2. Send reset link via email
3. User clicks link → Redirects to password reset
4. User creates new password
5. Auto-login after reset
```

### Security Rules

**Firestore Rules:**
```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users can read/write their own document
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth.uid == userId;
    }
    
    // Anyone can read tournaments
    match /tournaments/{tournamentId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update: if request.auth != null && 
        (resource.data.adminId == request.auth.uid || 
         request.auth.uid in resource.data.teams[].players);
      allow delete: if request.auth.uid == resource.data.adminId;
    }
    
    // Matches - read by tournament participants, write by participants + admin
    match /matches/{matchId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
    }
    
    // Notifications - user can only read their own
    match /notifications/{notificationId} {
      allow read: if request.auth.uid == resource.data.userId;
      allow write: if false; // Only backend can write
    }
  }
}
```

---

## App Architecture

### Navigation Structure

```
Root Navigator (Stack)
├── Auth Navigator (if not logged in)
│   ├── Welcome Screen
│   ├── Signup Screen
│   └── Login Screen
│
└── App Navigator (if logged in)
    ├── Tab Navigator (Bottom Tabs)
    │   ├── Home Tab
    │   ├── Compete Tab
    │   ├── Updates Tab
    │   └── Profile Tab
    │
    └── Modal Stack (Overlays)
        ├── Create Tournament Modal
        ├── Tournament Detail Modal
        ├── Match Detail Modal
        └── Edit Profile Modal
```

### State Management

**Global State (React Context):**

**AuthContext:**
```javascript
{
  user: object | null,        // Current user data
  isAuthenticated: boolean,
  isLoading: boolean,
  login: function,
  logout: function,
  signup: function
}
```

**UserContext:**
```javascript
{
  profile: object,            // User profile data
  stats: object,              // User statistics
  updateProfile: function,
  refreshStats: function
}
```

**TournamentContext (Optional):**
```javascript
{
  activeTournament: object | null,
  tournaments: array,
  createTournament: function,
  updateTournament: function,
  deleteTournament: function
}
```

### Data Flow

```
User Action (UI)
    ↓
Component Event Handler
    ↓
Service Function (Firebase)
    ↓
Firestore Database
    ↓
Real-time Listener (onSnapshot)
    ↓
Update Context State
    ↓
Re-render Components
```

---

## Key Features Implementation

### 1. Tournament Creation

**Flow:**
```javascript
1. User fills form (7 fields)
2. Validate inputs:
   - Name: Required, min 3 chars
   - Photo: Optional, max 5MB
   - Location: Required
   - DateTime: Required, future date
   - Court Numbers: Required, comma-separated
   - Teams: Required, multiple of 4
   - Rules: Optional
3. Upload photo to Firebase Storage (if provided)
4. Create tournament document in Firestore
5. Navigate to tournament detail page
6. Generate shareable link
```

**Key Logic:**
```javascript
const createTournament = async (formData) => {
  // Upload photo
  const photoURL = formData.photo 
    ? await uploadToStorage(formData.photo) 
    : null;
  
  // Create tournament
  const tournamentRef = await firestore.collection('tournaments').add({
    name: formData.name,
    photo: photoURL,
    location: formData.location,
    dateTime: formData.dateTime,
    courtNumbers: formData.courtNumbers.split(',').map(c => c.trim()),
    format: 'worldCup',
    numberOfTeams: formData.numberOfTeams,
    rules: formData.rules,
    status: 'registration',
    adminId: currentUser.uid,
    teams: [],
    groups: null,
    createdAt: serverTimestamp(),
    updatedAt: serverTimestamp()
  });
  
  return tournamentRef.id;
};
```

---

### 2. Team Formation (Player Self-Join)

**Logic:**
```javascript
const joinTournament = async (tournamentId, userId, action) => {
  const tournament = await getTournament(tournamentId);
  
  if (action === 'createNewTeam') {
    // Create new team with user as first player
    const newTeam = {
      teamId: generateId(),
      name: `Team ${tournament.teams.length + 1}`,
      players: [userId],
      groupId: null,
      stats: { played: 0, won: 0, lost: 0, points: 0 }
    };
    
    tournament.teams.push(newTeam);
  } 
  else if (action === 'joinTeam') {
    // Add user as second player to incomplete team
    const incompleteTeam = tournament.teams.find(t => t.players.length === 1);
    incompleteTeam.players.push(userId);
  }
  
  // Update tournament
  await firestore.collection('tournaments').doc(tournamentId).update({
    teams: tournament.teams,
    updatedAt: serverTimestamp()
  });
};
```

---

### 3. Tournament Start & Group Generation

**Logic:**
```javascript
const startTournament = async (tournamentId) => {
  const tournament = await getTournament(tournamentId);
  
  // 1. Generate random groups
  const shuffledTeams = shuffleArray(tournament.teams);
  const teamsPerGroup = tournament.numberOfTeams / 
    (tournament.numberOfTeams <= 8 ? 2 : 4);
  
  const groups = [];
  for (let i = 0; i < shuffledTeams.length / teamsPerGroup; i++) {
    const groupTeams = shuffledTeams.slice(
      i * teamsPerGroup, 
      (i + 1) * teamsPerGroup
    );
    
    groups.push({
      groupId: generateId(),
      name: `Group ${String.fromCharCode(65 + i)}`, // A, B, C...
      teamIds: groupTeams.map(t => t.teamId)
    });
  }
  
  // 2. Assign groups to teams
  groups.forEach(group => {
    group.teamIds.forEach(teamId => {
      const team = tournament.teams.find(t => t.teamId === teamId);
      team.groupId = group.groupId;
    });
  });
  
  // 3. Generate match schedule
  const matches = generateMatches(tournament, groups);
  
  // 4. Update tournament status
  await firestore.collection('tournaments').doc(tournamentId).update({
    status: 'groupStage',
    teams: tournament.teams,
    groups: groups,
    updatedAt: serverTimestamp()
  });
  
  // 5. Create match documents
  const batch = firestore.batch();
  matches.forEach(match => {
    const matchRef = firestore.collection('matches').doc();
    batch.set(matchRef, match);
  });
  await batch.commit();
  
  // 6. Send notifications
  await sendTournamentStartNotifications(tournament);
};
```

---

### 4. Match Scheduling with Court Assignment

**Auto-Staggered Logic:**
```javascript
const generateMatches = (tournament, groups) => {
  const matches = [];
  const courts = tournament.courtNumbers;
  const startTime = tournament.dateTime;
  
  // Calculate match interval (e.g., every 30 minutes)
  const totalMatches = calculateTotalMatches(tournament);
  const matchInterval = 30; // minutes
  
  let currentTime = startTime;
  let courtIndex = 0;
  
  // Group stage matches
  groups.forEach(group => {
    const groupTeams = tournament.teams.filter(t => t.groupId === group.groupId);
    
    // Generate round-robin matches for group
    for (let i = 0; i < groupTeams.length; i++) {
      for (let j = i + 1; j < groupTeams.length; j++) {
        matches.push({
          matchId: generateId(),
          tournamentId: tournament.tournamentId,
          round: 'groupStage',
          groupId: group.groupId,
          team1Id: groupTeams[i].teamId,
          team2Id: groupTeams[j].teamId,
          dateTime: new Date(currentTime.getTime() + (matches.length * matchInterval * 60000)),
          court: courts[courtIndex % courts.length], // Rotate courts
          status: 'scheduled',
          result: null,
          createdAt: serverTimestamp()
        });
        
        courtIndex++;
      }
    }
  });
  
  // Knockout matches (generated later after group stage)
  
  return matches;
};
```

---

### 5. Match Result Recording

**Logic:**
```javascript
const recordMatchResult = async (matchId, result) => {
  // 1. Validate scores
  if (!validatePadelScore(result.team1Score, result.team2Score)) {
    throw new Error('Invalid score');
  }
  
  // 2. Determine winner
  const team1SetsWon = result.team1Score.filter((score, i) => 
    score > result.team2Score[i]).length;
  const team2SetsWon = result.team2Score.filter((score, i) => 
    score > result.team1Score[i]).length;
  
  const winnerId = team1SetsWon > team2SetsWon 
    ? result.team1Id 
    : result.team2Id;
  
  // 3. Update match
  await firestore.collection('matches').doc(matchId).update({
    status: 'completed',
    result: {
      team1Score: result.team1Score,
      team2Score: result.team2Score,
      winnerId: winnerId,
      recordedBy: currentUser.uid,
      recordedAt: serverTimestamp()
    }
  });
  
  // 4. Update team standings
  await updateStandings(match.tournamentId);
  
  // 5. Check if tournament phase complete
  await checkPhaseCompletion(match.tournamentId);
  
  // 6. Send notifications
  await sendMatchResultNotifications(matchId);
};
```

---

## Real-time & Notifications

### Real-time Listeners (Firestore)

**Tournament Updates:**
```javascript
useEffect(() => {
  const unsubscribe = firestore
    .collection('tournaments')
    .doc(tournamentId)
    .onSnapshot(doc => {
      setTournament(doc.data());
    });
  
  return () => unsubscribe();
}, [tournamentId]);
```

### Push Notifications (FCM)

**Setup:**
```javascript
// Request permission
const { status } = await Notifications.requestPermissionsAsync();

// Get push token
const token = await Notifications.getExpoPushTokenAsync();

// Save token to user document
await firestore.collection('users').doc(userId).update({
  pushToken: token.data
});
```

**Send Notification (Cloud Function):**
```javascript
exports.sendMatchReminder = functions.firestore
  .document('matches/{matchId}')
  .onCreate(async (snap, context) => {
    const match = snap.data();
    
    // Schedule notification 30 min before match
    const scheduleTime = match.dateTime - (30 * 60 * 1000);
    
    // Get player tokens
    const players = await getMatchPlayers(match);
    const tokens = players.map(p => p.pushToken);
    
    // Send notification
    await admin.messaging().sendMulticast({
      tokens: tokens,
      notification: {
        title: 'Match Reminder',
        body: 'Your match starts in 30 minutes'
      },
      data: {
        matchId: match.matchId,
        tournamentId: match.tournamentId
      }
    });
  });
```

**Notification Types:**
1. Tournament invitation
2. Tournament starting (day before)
3. Match reminder (30 min before)
4. Match result posted
5. Tournament cancelled

---

## Deep Linking

### Configuration

**app.json:**
```json
{
  "expo": {
    "scheme": "smash",
    "android": {
      "intentFilters": [
        {
          "action": "VIEW",
          "data": [
            {
              "scheme": "https",
              "host": "smash.app",
              "pathPrefix": "/tournament"
            }
          ],
          "category": ["BROWSABLE", "DEFAULT"]
        }
      ]
    },
    "ios": {
      "associatedDomains": ["applinks:smash.app"]
    }
  }
}
```

**Link Format:**
```
smash://tournament/{tournamentId}
https://smash.app/tournament/{tournamentId}
```

**Handling:**
```javascript
// App.jsx
import * as Linking from 'expo-linking';

useEffect(() => {
  // Handle initial URL
  Linking.getInitialURL().then(url => {
    if (url) handleDeepLink(url);
  });
  
  // Listen for URL changes
  const subscription = Linking.addEventListener('url', ({ url }) => {
    handleDeepLink(url);
  });
  
  return () => subscription.remove();
}, []);

const handleDeepLink = (url) => {
  const { path, queryParams } = Linking.parse(url);
  
  if (path === 'tournament/:id') {
    // Navigate to tournament
    navigation.navigate('TournamentDetail', { 
      tournamentId: queryParams.id 
    });
  }
};
```

---

## Development Setup

### Initial Setup

**1. Clone Repository:**
```bash
git clone https://github.com/your-username/smash-app.git
cd smash-app
```

**2. Install Dependencies:**
```bash
npm install
```

**3. Configure Firebase:**
```bash
# Add Firebase config to firebase.json
# Get config from Firebase Console
```

**4. Add Environment Variables:**
```bash
# Create .env file
FIREBASE_API_KEY=your_api_key
FIREBASE_AUTH_DOMAIN=your_auth_domain
FIREBASE_PROJECT_ID=your_project_id
```

**5. Install Fonts:**
```bash
# Place General Sans fonts in /assets/fonts/
GeneralSans-Regular.otf
GeneralSans-Medium.otf
GeneralSans-Semibold.otf
```

**6. Start Development:**
```bash
npx expo start
```

**7. Test on Device:**
- Scan QR code with Expo Go app
- Or press 'w' for web preview

---

### Development Workflow

**Local Development:**
```bash
# Start Expo
npx expo start

# Clear cache if needed
npx expo start -c

# Run on specific platform
npx expo start --ios
npx expo start --android
```

**GitHub Codespaces:**
```bash
# Already configured, just run:
npx expo start --tunnel
```

---

## Deployment

### Expo EAS Build

**Setup:**
```bash
# Install EAS CLI
npm install -g eas-cli

# Login
eas login

# Configure build
eas build:configure
```

**Build Commands:**
```bash
# Development build (for testing)
eas build --platform ios --profile development
eas build --platform android --profile development

# Production build
eas build --platform ios --profile production
eas build --platform android --profile production

# Submit to stores
eas submit --platform ios
eas submit --platform android
```

### Testing Distribution

**TestFlight (iOS):**
```bash
eas build --platform ios --profile preview
eas submit --platform ios --latest
```

**Google Play Internal Testing:**
```bash
eas build --platform android --profile preview
eas submit --platform android --latest
```

---

## Performance Optimization

### Best Practices

**1. Image Optimization:**
```javascript
// Use optimized images
<Image 
  source={{ uri: imageUrl }}
  style={styles.image}
  resizeMode="cover"
  cachePolicy="memory-disk"
/>
```

**2. List Performance:**
```javascript
// Use FlatList for long lists
<FlatList
  data={tournaments}
  renderItem={({ item }) => <TournamentCard tournament={item} />}
  keyExtractor={item => item.id}
  removeClippedSubviews={true}
  maxToRenderPerBatch={10}
  windowSize={21}
/>
```

**3. Memoization:**
```javascript
// Memoize expensive components
const TournamentCard = React.memo(({ tournament }) => {
  // Component code
});
```

**4. Firestore Query Optimization:**
```javascript
// Use compound queries with indexes
const tournaments = await firestore
  .collection('tournaments')
  .where('status', '==', 'registration')
  .where('adminId', '==', userId)
  .orderBy('dateTime', 'desc')
  .limit(20)
  .get();
```

---

## Security Considerations

### Best Practices

1. **Never expose API keys in code** - Use environment variables
2. **Validate all inputs** - Client and server-side
3. **Use Firestore Security Rules** - Restrict data access
4. **Sanitize user inputs** - Prevent injection attacks
5. **Implement rate limiting** - Prevent abuse
6. **Use HTTPS only** - For all network requests
7. **Validate email codes** - Expire after 10 minutes
8. **Hash sensitive data** - Never store plain text passwords

---

## Monitoring & Analytics

### Firebase Analytics
```javascript
import { logEvent } from 'firebase/analytics';

// Track key events
logEvent('tournament_created');
logEvent('match_completed');
logEvent('user_signup');
```

### Error Tracking
```javascript
// Use Sentry or similar
import * as Sentry from 'sentry-expo';

Sentry.init({
  dsn: 'your-dsn',
  enableInExpoDevelopment: true,
});
```

---

## API Rate Limits & Quotas

### Firebase Free Tier (Spark Plan)

**Firestore:**
- Reads: 50,000/day
- Writes: 20,000/day
- Deletes: 20,000/day
- Storage: 1GB

**Authentication:**
- Unlimited

**Cloud Storage:**
- 5GB storage
- 1GB/day download

**Cloud Messaging:**
- Unlimited

**For MVP (100 users):** Free tier is sufficient ✅

---

## Testing Strategy

### Testing Levels

**1. Component Testing:**
```javascript
// Use React Native Testing Library
import { render } from '@testing-library/react-native';

test('Button renders correctly', () => {
  const { getByText } = render(<Button title="Press me" />);
  expect(getByText('Press me')).toBeTruthy();
});
```

**2. Integration Testing:**
- Test user flows end-to-end
- Test navigation between screens
- Test Firebase operations

**3. Manual Testing:**
- Test on real devices (iOS + Android)
- Test offline scenarios
- Test push notifications
- Test deep links

---

## Troubleshooting

### Common Issues

**Expo Go not loading:**
```bash
# Try tunnel mode
npx expo start --tunnel

# Clear cache
npx expo start -c
```

**Firebase errors:**
```bash
# Check Firebase config
# Verify API keys in .env
# Check Firestore rules
```

**Font not loading:**
```bash
# Verify font files in /assets/fonts/
# Check font names in code
# Reload app after font changes
```

---

**End of Technical Specifications**

For implementation details, refer to PRD.md and DESIGN.md.
For development workflow, see PROJECT_CONTEXT.md.